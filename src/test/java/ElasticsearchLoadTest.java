import com.google.common.base.Throwables;
import com.google.common.util.concurrent.RateLimiter;
import org.elasticsearch.action.bulk.BulkRequestBuilder;
import org.elasticsearch.action.bulk.BulkResponse;
import org.elasticsearch.client.Client;
import org.elasticsearch.node.Node;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;

import static org.elasticsearch.node.NodeBuilder.nodeBuilder;
/*
 * This Java source file was auto generated by running 'gradle init --type java-library'
 * by 'Kyle' at '12/6/14 4:57 PM' with Gradle 2.2
 *
 * @author Kyle, @date 12/6/14 4:57 PM
 */
@RunWith(Parameterized.class)
public class ElasticsearchLoadTest {

    // message rate
    // number of threads (users)
    // number of loops per thread (user)
    // option of infinite looping
    // time limit for looping

    private int numUsers;
    private int durationInSeconds;
    private int messageRatePerSecond;
    private int bulkSize;

    public ElasticsearchLoadTest(int numUsers, int durationInSeconds, int messageRatePerSecond, int bulkSize) {
        this.numUsers = numUsers;
        this.durationInSeconds = durationInSeconds;
        this.messageRatePerSecond = messageRatePerSecond;
        this.bulkSize = bulkSize;
    }

    @Parameterized.Parameters
    public static Collection<Object[]> returnParameters() {
        return Arrays.asList(new Object[][] {
                {5, 60, 1000, 3250}
        });
    }

    @Test
    public void loadTestElasticsearch() throws InterruptedException, ExecutionException {
        System.out.printf("Started elasticsearch load test with the following parameters...\n%s users\n%s seconds long\n%s message per second\n%s messages per bulk request\n\n",
                numUsers,
                durationInSeconds,
                messageRatePerSecond,
                bulkSize
        );
        ExecutorService executorService = Executors.newFixedThreadPool(numUsers);
        List<UserThread> threadList = Collections.synchronizedList(new ArrayList<>(numUsers));
        System.out.println("Creating threads...");
        ExecutorService threadSetupService = Executors.newFixedThreadPool(numUsers);
        AtomicInteger atomicInteger = new AtomicInteger(0);
        Collection<Callable<Void>> callables = new ArrayList<>(numUsers);
        for (int i = 0; i < numUsers; i++) {
            callables.add(new Callable<Void>() {
                @Override
                public Void call() throws Exception {
                    Node node = nodeBuilder().clusterName("elasticsearch").client(true).node();
                    UserThread userThread = new UserThread(atomicInteger.incrementAndGet(), RateLimiter.create(messageRatePerSecond), node, bulkSize);
                    threadList.add(userThread);
                    System.out.printf("Created thread with id: %s\n", userThread.getId());
                    return null;
                }
            });
        }

        List<Future<Void>> futures = threadSetupService.invokeAll(callables);
        for (Future future : futures) {
            future.get();
        }

        System.out.printf("Starting threads...\n");
        System.out.printf("Test running for %s seconds\n", durationInSeconds * 1000);
        threadList.forEach(thread -> executorService.execute(thread));


        Thread.sleep(durationInSeconds * 1000L);

        System.out.println("\nShutting down threads.");
        threadList.forEach(userThread -> userThread.stop());
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS);
        int totalMessages = 0;
        for (UserThread thread : threadList) {
            totalMessages += thread.getCtr();
        }

        System.out.println("Total messages processed: " + totalMessages);
        System.out.printf("Messages per second (attempted/actual: %s/%s\n", totalMessages / durationInSeconds,
                numUsers * messageRatePerSecond);
    }

    class UserThread implements Runnable {
        private Node node;
        private Client client;
        private RateLimiter messageRateLimiter;
        private int bulkSize;
        private long id;
        private boolean stop = false;
        private long ctr = 0;

        public UserThread(long id, RateLimiter messageRateLimiter, Node node, int bulkSize) {
            this.id = id;
            this.messageRateLimiter = messageRateLimiter;
            this.node = node;
            this.client = node.client();
            this.bulkSize = bulkSize;
        }

        @Override
        public void run() {
            
            try {
                BulkRequestBuilder bulkRequest = client.prepareBulk();

                // read the file of tweets line by line in a loop until the ExecutorService shuts us down
                while (!stop) {
                    BufferedReader br = new BufferedReader(new FileReader(getClass().getClassLoader().getResource("1ktwittermsgs").getFile()));
                    String line;
                    while ((line = br.readLine()) != null && !stop) {
                        messageRateLimiter.acquire();
                        ctr++;
                        bulkRequest.add(client.prepareIndex("twitter", "tweet").setSource(line).request());
                        if (ctr % bulkSize == 0) {
                            System.out.printf("id, ctr: %s - %s\n", id, ctr);
                            BulkResponse bulkResponse = bulkRequest.execute().actionGet();
                            if (bulkResponse.hasFailures()) {
                                System.out.println(bulkResponse.buildFailureMessage());
                            }
                            // reset the bulkRequest for next time
                            bulkRequest = null;
                            bulkRequest = client.prepareBulk();
                        }
                    }
                }

                // flush any extra messages left in the bulkRequest;
                if (bulkRequest.numberOfActions() > 0) {
                    BulkResponse bulkResponse = bulkRequest.execute().actionGet();
                    if (bulkResponse.hasFailures()) {
                        System.out.println(bulkResponse.buildFailureMessage());
                    }
                }

            } catch (IOException e) {
                System.out.println(Throwables.getStackTraceAsString(e));
            } finally {
                System.out.printf("Closing node for thread %s\n", id);
                node.close();
            }
        }

        public void stop() {
            this.stop = true;
        }

        public long getCtr() {
            return ctr;
        }

        public long getId() {
            return id;
        }
    }


}
